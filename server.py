from flask import Flask, request, send_file
import requests
import subprocess
import win32api, win32file
import os
import zipfile
import time

app = Flask(__name__)

UPLOAD_FOLDER = r"C:\malwareTraces\uploads"
INFO_FOLDER = r"C:\malwareTraces\packet_info"
MALWARE_INFO_CSV = r"C:\malwareTraces\malware_data.csv"
CAPTURE_FILE = r"C:\malwareTraces\capture.pcap"
RESULT_ZIP = r"C:\malwareTraces\result.zip"

malware_analyzer_pid=0

def create_malware_info_csv():
    csv_fields = ["timestamp", "syscall", "srcIp", "dstIP", 
                "protocol", "srcPort", "dstPort", "pid",
                    "threadId", "ppid", "appName", "domainName" ]

    combined_data = []
    # Inserisco tutte le informazioni ottenute dalla DLL in unica lista
    for filename in os.listdir(INFO_FOLDER):
        if filename.endswith('.txt'):
            file_path = os.path.join(INFO_FOLDER, filename)

            with open(file_path, 'r') as file:
                lines = file.readlines()
                combined_data.extend(lines)

    # Ordino le informazioni in base al timestamp
    combined_data.sort(key=lambda csv_line: csv_line.strip().split(",")[0])

    # Scrivo header e contenuto del CSV
    with open(MALWARE_INFO_CSV, 'w') as out_file:
        out_file.write(','.join(csv_fields) + '\n')
        out_file.writelines(combined_data)

    print(f'Concatenated data saved to {MALWARE_INFO_CSV}')
    return

'''
Funzione che ferma il processo di cattura inviando il messaggio
"STOP" al namedPipe server del processo
Non serve - La lascio per debugging, ma cancellero' la funzione una volta finito
'''
def stop_capture():
    pipe_name = r'\\.\pipe\captureProcessPipe'

    try:
        pipe_handle = win32file.CreateFile(
            pipe_name,
            win32file.GENERIC_READ | win32file.GENERIC_WRITE,
            0, None,
            win32file.OPEN_EXISTING,
            0, None
        )

        win32file.WriteFile(pipe_handle, b"STOP")
    except Exception as e:
        print("Error:", e)
    finally:
        try:
            win32file.CloseHandle(pipe_handle)
        except NameError:
            pass

def is_pid_running(pid: int) -> bool:
    try:
        handle = win32api.OpenProcess(0x0001, False, pid)
        if handle:
            win32api.CloseHandle(handle)
            return True
        return False
    except Exception as e:
        print(f"Error checking PID: {str(e)}")
        return False

'''
Endpoint per far scaricare al server un file da un URL
Il file verra' chiamato con il nome presente nell'URL
Se l'URL e' "https://example.com/folder/file.exe", il file sara' chiamato "file.exe"
Es: curl -i -XPOST --data 'url=https://example.com/file.exe' http://192.168.122.189:5000/download
'''
@app.route('/download', methods=['POST'])
def download():
    url = request.form.get('url')
    filename = url.split("/")[-1]
    response = requests.get(url)

    file_path = os.path.join(UPLOAD_FOLDER, filename)

    with open(file_path, 'wb') as file:
        file.write(response.content)
    return "File downloaded successfully."

'''
Endpoint che permette all'utente di caricare un file nel server
E' necessario eseguire una POST contenente il campo 'file'
Es: curl -X POST -F "file=@/home/user/files/infiniteNetworkRequests.exe" http://server.ip/upload
'''
@app.route('/upload', methods=['POST'])
def upload():
    if 'file' not in request.files:
        return "No file part", 404

    file = request.files['file']
    if file.filename == '':
        return "No selected file", 404

    filename = file.filename
    file.save(os.path.join(UPLOAD_FOLDER, filename))

    return "File uploaded successfully.", 200

'''
Endpoint che fa iniziare il processo di cattura
E' necessario effettuare una HTTP POST contentente i campi:
1. 'command' - Obbligatorio - Path del binario da analizzare
2. 'args' - Facoltativo - Argomenti da passare al binario
Se viene inviato solo il nome del binario, il server lo cerca nella cartella di upload, altrimenti ipotizzo sia stato passato un path assoluto
curl -i -H "Content-Type: application/json" -XPOST --data '{"command" : "infiniteNetworkRequests.exe", "args" : ""}' http://192.168.122.189:5000/start
curl -i -H "Content-Type: application/json" -XPOST --data '{"command" : "C:/Windows/System32/ping.exe", "args" : "-a -n 3 192.168.122.1"}' http://192.168.122.189:5000/start
'''
@app.route('/start', methods=['POST'])
def start():
    global malware_analyzer_pid

    python_exe = r"C:\Users\user\AppData\Local\Microsoft\WindowsApps\python3.11.exe"
    capture_script = r"C:\malwareTraces\capture.py"
    capture_process = subprocess.Popen([python_exe, capture_script])

    injector_exe = r"C:\malwareTraces\MalwareTracesInjector.exe"
    data = request.get_json(force=True)
    command = data.get('command', '')
    args = data.get('args', '')

    full_command = []
    full_command.append(injector_exe)

    # Controllo se il comando e' nella cartella di upload
    uploaded_files = os.listdir(UPLOAD_FOLDER)
    if command in uploaded_files:
        full_command.append(os.path.join(UPLOAD_FOLDER, command))
    else:
        full_command.append(command)

    full_command.append(args)
    #print(full_command)
    time.sleep(2)
    
    injector_process = subprocess.Popen(full_command)
    malware_analyzer_pid = injector_process.pid
    
    return "Starting Malware Analyzer", 200, {'content-type': 'text/html'}

# Da aggiustare. Ci sono molti casi in cui l'endpoint potrebbe restituire
# un'informazione sbagliata
@app.route('/check', methods=['GET'])
def check():
    global malware_analyzer_pid
    if is_pid_running(malware_analyzer_pid):
        return "Program is running", 200, {'Content-Type': 'text/html'}
    return "Program is NOT running", 404, {'Content-Type': 'text/html'}

# Quando una richiesta arriva a questo endpoint, il server produce
# uno zip contentente i file del risultato e lo invia all'utente
@app.route('/result', methods=['GET'])
def result():
    stop_capture()
    create_malware_info_csv()

    # Creo lo zip dei file da restituire
    try:
        files_to_zip = [MALWARE_INFO_CSV, CAPTURE_FILE]
        with zipfile.ZipFile(RESULT_ZIP, 'w') as zipf:
            for file_path in files_to_zip:
                zipf.write(file_path)
    except:
        return "Error in result processing.", 404, {'Content-Type': 'text/html'}

    # Invio lo zip all'utente
    return send_file(RESULT_ZIP, as_attachment=True)

if __name__ == '__main__':
    #  Controllo, ed eventualmente creo, le cartelle necessarie
    if not os.path.exists(INFO_FOLDER):
        os.makedirs(INFO_FOLDER)
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)

    app.run(host='0.0.0.0', port=5000)